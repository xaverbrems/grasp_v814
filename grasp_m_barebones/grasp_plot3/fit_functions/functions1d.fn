%Parameters avaliable for fitting, autoguess and point & click
%x  - column of x values in zoomed display window
%y  - column of intensities corresponding to x coordinate above 

%********************************************************************************************************
<Divider>
----General Functions----
</Divider>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Beam Shutters
</FnName>

<Params>
Bck
H3
H4
H5
H8
H10
H11
H12
H13
Thales
D3
D9
IN1D4
D20
IN20
IN8
IN4
D2B
Granit
</Params>

<StartValues>
10
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
</StartValues>

<ParamNames>
Background
H3(D9)
H4(D3)
H5(ILL22)
H8(IN1D4)
H10(IN8)
H11(D20D2B)
H12(IN4)
H13(IN20)
Thales
D3
D9
IN1D4
D20
IN20
IN8
IN4
D2B
Granit
</ParamNames>

<FnCode>
y = shutter_fit(x,Bck,H3,H4,H5,H8,H10,H11,H12,H13,Thales,D3,D9,IN1D4,D20,IN20,IN8,IN4,D2B,Granit);
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>







<Function>

<FnName>
Gaussian
</FnName>

<Params>
y0
i0
xc
fwhm
</Params>

<StartValues>
0
1000
0.5
1
</StartValues>

<ParamNames>
Background
Integrated Intensity
Centre
FWHM
</ParamNames>

<FnCode>
y = y0 + (i0 / (fwhm*sqrt(pi/2) / sqrt(log(4)))) .* exp((-2*(x-xc).^2) / (fwhm.^2 / log(4)));
</FnCode>

<AutoGuessCode>
[amp i_amp] = max(y);    %Peak Intensity
xc = x(i_amp);         %Centre Position
y0 = min(y);         %Background
x_diff = diff(x); %Differences between adjacent x's.
ytemp = y(1:length(y)-1);
i0 = abs((sum((ytemp-y0).*x_diff)));
sigma = i0/(amp*sqrt(2*pi));
fwhm = 2*sqrt(2*log(2))*sigma; %The sqrt is because this is a 2D gaussian
guess_values = [y0, i0, xc, fwhm];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub'); %Grasp Message
[x y0]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak'],1,'sub');  %Grasp Message
[xc amp]=ginput(1); %Mouse input, Centre and Peak intensity
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak Width'],1,'sub');  %Grasp Message
[fwhm y]=ginput(1); %Mouse input
delete(text_handle);drawnow;
fwhm=abs(fwhm-xc);
amp=amp-y0;
i0 = amp*fwhm*sqrt(pi)/(sqrt(2)*sqrt(2*log(2))); %Convert Peak Intensity to IntInt
%Put estimated parameters into the output array.
guess_values = [y0, i0, xc, fwhm];
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
Lorentzian
</FnName>

<Params>
y0
i0
xc
fwhm
</Params>

<StartValues>
0
1000
0
0.5
</StartValues>

<ParamNames>
Background
Integrated Intensity
Centre
FWHM
</ParamNames>

<FnCode>
y = y0 + ((2*i0/pi)*fwhm)./(4*((x-xc).^2)+(fwhm.^2));
</FnCode>

<AutoGuessCode>
[amp i_amp] = max(y); %Peak Intensity
xc = x(i_amp); %Centre Position
y0 = min(y);
x_diff = diff(x); %Differences between adjacent x's.
ytemp = y(1:length(y)-1);
i0 = (sum((ytemp-y0).*x_diff));
sigma = i0/(amp*pi);
fwhm = 2*sigma; 
guess_values = [y0, i0, xc, fwhm];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');
[x y0]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak'],1,'sub');
[xc amp]=ginput(1); %Centre and Peak
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Width'],1,'sub');
[fwhm y]=ginput(1); %Width Position
delete(text_handle);drawnow;
fwhm=(abs(fwhm-xc)*2); %FWHM
amp=amp-y0;
i0 = amp*pi*fwhm/2; %Now calcualate the int int.
guess_values = [y0, i0, xc, fwhm];
</PointClickCode>

</Function>
%********************************************************************************************************






%********************************************************************************************************
<Function>

<FnName>
Linear
</FnName>

<Params>
m
c
</Params>

<StartValues>
1
0
</StartValues>

<ParamNames>
Gradient
Offset
</ParamNames>

<FnCode>
y = m.*x + c;
</FnCode>

<AutoGuessCode>
[ymax i_ymax] = max(y);
[ymin i_ymin] = min(y);
m = (ymax -ymin)/(x(i_ymax)-x(i_ymin));
c = ymin - m*x(i_ymin);
guess_values = [m, c];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Xmax:Ymax'],1,'sub');
[xmax ymax]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Xmin:Ymin'],1,'sub');
[xmin ymin]=ginput(1);
delete(text_handle);drawnow;
m = (ymax - ymin) / (xmax-xmin);
c = ymin - (xmin*m);
guess_values = [m, c];
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Expontential
</FnName>

<Params>
a
b
c
</Params>

<StartValues>
1
1
0
</StartValues>

<ParamNames>
Scalar
Power
Offset
</ParamNames>

<FnCode>
y = a.*x.^b + c;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
Poly2
</FnName>

<Params>
a
b
c
</Params>

<StartValues>
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
</ParamNames>

<FnCode>
y = a + b.*x + c.*x.^2;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Poly3
</FnName>

<Params>
a
b
c
d
</Params>

<StartValues>
1
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
Coef3
</ParamNames>

<FnCode>
y = a + b.*x + c.*x.^2 + d.*x.^3;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Poly4
</FnName>

<Params>
a
b
c
d
e
</Params>

<StartValues>
1
1
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
Coef3
Coef4
</ParamNames>

<FnCode>
y = a + b.*x + c.*x.^2 + d.*x.^3 + e.*x.^4;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Poly5
</FnName>

<Params>
a
b
c
d
e
f
</Params>

<StartValues>
1
1
1
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
Coef3
Coef4
Coef5
</ParamNames>

<FnCode>
y = a + b.*x + c.*x.^2 + d.*x.^3 + e.*x.^4 + f.*x.^5;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Poly6
</FnName>

<Params>
a
b
c
d
e
f
g
</Params>

<StartValues>
1
1
1
1
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
Coef3
Coef4
Coef5
Coef6
</ParamNames>

<FnCode>
y = a + b.*x + c.*x.^2 + d.*x.^3 + e.*x.^4 + f.*x.^5 + g.*x.^6;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
LogLogPoly2
</FnName>

<Params>
a
b
c
</Params>

<StartValues>
1
1
1
</StartValues>

<ParamNames>
Offset
Coef1
Coef2
</ParamNames>

<FnCode>
y = a+ exp(b.*log10(x) + c.*log10(x).^2);
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Divider>
----Form Factor & Scattering Functions----
</Divider>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
1/q^4 Porod
</FnName>

<Params>
y0
sv
c
</Params>

<StartValues>
0
1
1e-6
</StartValues>

<ParamNames>
Background [cm^-1]
Specific Surface [A^2]
Contrast [A^-2]
</ParamNames>

<FnCode>
y = y0 + 2*pi*c*sv*x.^-4;
</FnCode>

<AutoGuessCode>
[ymax, imax] = max(y);
[y0, imin] = min(y);
xymax = x(imax);
xymin = x(imin);
m = 10^(log10(ymax)+4*log10(xymax));
csv = m/(2*pi);
sv=1;
c = csv;
guess_values = [y0, sv, c];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Message
[temp y0]=ginput(1) %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a High Data Point'],1,'sub');  %Grasp Message
[xymax ymax]=ginput(1) %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a Low Data'],1,'sub');  %Grasp Text Message
[xymin ymin]=ginput(1) %Mouse input
delete(text_handle);drawnow;
m = 10^(log10(ymax)+4*log10(xymax));
csv = m/(2*pi);
sv=1;
c = csv;
guess_values = [y0, sv, c];
</PointClickCode>

</Function>
%********************************************************************************************************





%********************************************************************************************************
<Function>

<FnName>
1/q^n
</FnName>

<Params>
y0
m
n
</Params>

<StartValues>
0
1000
4
</StartValues>

<ParamNames>
Background
Multiplier
Power
</ParamNames>

<FnCode>
y = y0 + m*x.^(-n);
</FnCode>

<AutoGuessCode>
[ymax, imax] = max(y);
[y0, imin] = min(y);
xymax = x(imax);
xymin = x(imin);
n = (log10(y0) - log10(ymax)) / (log10(xymax)-log10(xymin));
m = 10^(log10(ymax)+n*log10(xymax))
guess_values = [y0, m, n];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Message
[temp y0]=ginput(1) %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a High Data Point'],1,'sub');  %Grasp Message
[xymax ymax]=ginput(1) %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a Low Data Point'],1,'sub');  %Grasp Message
[xymin ymin]=ginput(1) %Mouse input
delete(text_handle);drawnow;
n = (log10(ymin) - log10(ymax)) / (log10(xymax)-log10(xymin)); %Not needed, fixed at q^4
m = 10^(log10(ymax)+n*log10(xymax))
guess_values = [y0, m, n];
</PointClickCode>

</Function>
%********************************************************************************************************





%********************************************************************************************************
<Function>
<FnName>
Gaussian + 1/q^n
</FnName>

<Params>
y0
m
n
i0
xc
fwhm
</Params>

<StartValues>
0
1
4
1000
0
1
</StartValues>

<ParamNames>
Background
Multiplier
Power
Integrated Intensity
Centre
FWHM
</ParamNames>

<FnCode>
y = y0 + m*(x.^(-n)) + (i0/(fwhm*sqrt(pi/2)/(sqrt(log(4)))))*exp(-2*((x-xc).^2)/((fwhm.^2)/log(4)));
</FnCode>

<AutoGuessCode>
%Gaussian Autoguess
deriv = diff(y); %First Derivative
deriv2 = diff(deriv); %Second Derivative
[temp, peakindex] = min(deriv2); %Point of inflection
[gauss1 i1] = max(deriv);
[gauss2 i2] = min(deriv);
xc = x(peakindex);
amp = y(peakindex);
fwhm = abs(x(i1)-x(i2));
i0 = amp*pi*fwhm/2; %Now calculate the int int.
y0 = min(y);
%Q4 Auto Guess
[ymax, imax] = max(y);
[ymin, imin] = min(y);
xymax = x(imax);
xymin = x(imin);
n = (log10(ymin) - log10(ymax)) / (log10(xymax)-log10(xymin)); %Not needed, fixed at q^4
m = 10^(log10(ymax)+n*log10(xymax))
guess_values = [y0, m, n, i0, xc, fwhm];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');
[x y0]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a q^n High Data Point'],1,'sub');  %Grasp Message
[xymax ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a q^n Low Data Point'],1,'sub');  %Grasp Message
[xymin ymin]=ginput(1); %Mouse input
delete(text_handle);drawnow;
n = (log10(ymin) - log10(ymax)) / (log10(xymax)-log10(xymin));
m = 10^(log10(ymax)+n*log10(xymax))
text_handle = grasp_message(['Click on Gaussian Peak'],1,'sub');
[xc amp]=ginput(1); %Centre and Peak
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Gaussian Width No.'],1,'sub');
[fwhm y]=ginput(1); %Width Position
delete(text_handle);drawnow;
fwhm=(abs(fwhm-xc)*2); %FWHM
amp=amp-y0;
i0 = amp*pi*fwhm/2; %Now calcualate the int int.
guess_values = [y0, m, n, i0, xc, fwhm];
</PointClickCode>

</Function>
%********************************************************************************************************




%********************************************************************************************************
<Function>
<FnName>
Lorentzian + 1/q^n
</FnName>

<Params>
y0
m
n
i0
xc
fwhm
</Params>

<StartValues>
0
1
4
1000
0
1
</StartValues>

<ParamNames>
Background
Multiplier
Power
Integrated Intensity
Centre
FWHM
</ParamNames>

<FnCode>
y = y0 + m*(x.^(-n)) + ((2*i0/pi)*fwhm)./(4*((x-xc).^2)+(fwhm.^2));
</FnCode>

<AutoGuessCode>
%Lorentzian Autoguess
deriv = diff(y); %First Derivative
deriv2 = diff(deriv); %Second Derivative
[temp, peakindex] = min(deriv2); %Point of inflection
[gauss1 i1] = max(deriv);
[gauss2 i2] = min(deriv);
xc = x(peakindex);
amp = y(peakindex);
fwhm = abs(x(i1)-x(i2));
i0 = amp*pi*fwhm/2; %Now calculate the int int.
y0 = min(y);
%Q4 Auto Guess
[ymax, imax] = max(y);
[ymin, imin] = min(y);
xymax = x(imax);
xymin = x(imin);
n = (log10(ymin) - log10(ymax)) / (log10(xymax)-log10(xymin)); %Not needed, fixed at q^4
m = 10^(log10(ymax)+n*log10(xymax))
guess_values = [y0, m, n, i0, xc, fwhm];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');
[x y0]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a q^n High Data Point'],1,'sub');  %Grasp Message
[xymax ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on a q^n Low Data Point'],1,'sub');  %Grasp Message
[xymin ymin]=ginput(1); %Mouse input
delete(text_handle);drawnow;
n = (log10(ymin) - log10(ymax)) / (log10(xymax)-log10(xymin));
m = 10^(log10(ymax)+n*log10(xymax))
text_handle = grasp_message(['Click on Lorentzian Peak'],1,'sub');
[xc amp]=ginput(1); %Centre and Peak
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Lorentzian Width No.'],1,'sub');
[fwhm y]=ginput(1); %Width Position
delete(text_handle);drawnow;
fwhm=(abs(fwhm-xc)*2); %FWHM
amp=amp-y0;
i0 = amp*pi*fwhm/2; %Now calcualate the int int.
guess_values = [y0, m, n, i0, xc, fwhm];
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Guinier
</FnName>

<Params>
y0
k
rg
</Params>

<StartValues>
0
1
60
</StartValues>

<ParamNames>
Background
Scale
Radius Gyration
</ParamNames>


<FnCode>
y = y0 + k*exp( -((x.*rg).^2)/3);
</FnCode>

<AutoGuessCode>
[xmin, i_xmin] = min(x);
[xmax, i_xmax] = max(x);
y0 = y(i_xmax);
k = y(i_xmin) - y0;
derivative = diff(y,1);
[temp, i_ymin] = max(derivative);
disp(x(i_ymin))
rg = 4.49/x(i_ymin);
guess_values = [y0, k, rg];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
[xmin ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on High Q, Low Intensity Point'],1,'sub');  %Grasp Text Message
[xmax ymin]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Radius of Gyration'],1,'sub');  %Grasp Text Message
[qgradmax  temp]=ginput(1); %Mouse input
delete(text_handle);drawnow;
y0 = ymin;
k = ymax - ymin;
disp(qgradmax)
rg = 4.49/qgradmax; %4.49 = sqrt(3/5)*2pi conversion from Sphere R to Rg
guess_values = [y0, k, rg];
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
Guinier-Porod
</FnName>

<Params>
Bck
G
d
Rg
</Params>

<StartValues>
1
10
4
50
</StartValues>

<ParamNames>
Background
G
Porod Exponent
Radius Gyration
</ParamNames>


<FnCode>
Q1 = (1/Rg)*(3*d/2)^0.5;
D = G* exp(-d/2) * ((3*d/2)^(d/2)) * (1/(Rg^d));
temp = find(x<=Q1);
y(temp) = G.*exp(-x(temp).^2 .* Rg.^2 ./ 3);
temp = find(x>Q1);
y(temp) = D ./ (x(temp).^d);
y = y + Bck;
</FnCode>

<AutoGuessCode>
[xmin, i_xmin] = min(x);
[xmax, i_xmax] = max(x);
y0 = y(i_xmax);
k = y(i_xmin) - y0;
derivative = diff(y,1);
[temp, i_ymin] = max(derivative);
disp(x(i_ymin))
rg = 4.49/x(i_ymin);
guess_values = [y0, k, rg];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
[xmin ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on High Q, Low Intensity Point'],1,'sub');  %Grasp Text Message
[xmax ymin]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Radius of Gyration'],1,'sub');  %Grasp Text Message
[qgradmax  temp]=ginput(1); %Mouse input
delete(text_handle);drawnow;
y0 = ymin;
k = ymax - ymin;
disp(qgradmax)
rg = 4.49/qgradmax; %4.49 = sqrt(3/5)*2pi conversion from Sphere R to Rg
guess_values = [y0, k, rg];
</PointClickCode>

</Function>
%********************************************************************************************************









%********************************************************************************************************
<Function>

<FnName>
FF_Sphere
</FnName>

<Params>
y0
radius
contrast
scale
</Params>

<StartValues>
0.05
60
6e-6
0.01
</StartValues>

<ParamNames>
Background [cm-1]
Radius [A]
Contrast [A^-2]
Scale
</ParamNames>

<FnCode>
rq = (radius).* x;  %r [A] * q [A-1]  [Unitless]
contrast = contrast *1e8*1e8; %convert [A-2] to [cm-2];
V = (4/3)*pi*(radius*1e-8).^3; %Scatterer Volume in [cm3]
y = y0 + (scale./V) .* (3*V*contrast .*  (sin(rq) - (rq).*cos(rq)) ./ (rq).^3).^2;
</FnCode>

<AutoGuessCode>
            [xmin, i_xmin] = min(x);
            [xmax, i_xmax] = max(x);
            [bg i_ymin] = min(y);
            amp = y(i_xmin) - bg;
            derivative = diff(y,1);
            [temp, i_ymin] = max(derivative);
            r = 4.49/x(i_ymin);
contrast = 6e-6;
contrast = contrast;
scale = amp *contrast;
guess_values = [bg, r, contrast, scale];
</AutoGuessCode>

<PointClickCode>
        text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Text Message
        [xtemp bg]=ginput(1); %Mouse input
        delete(text_handle);drawnow;
        text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
            [xmin ymax]=ginput(1); %Mouse input
            delete(text_handle);drawnow;
            text_handle = grasp_message(['Click on First FF minimum'],1,'sub');  %Grasp Text Message
            [x1 y1]=ginput(1); %Mouse input
            amp = ymax-bg;
            r = 4.49/x1;
contrast = 6e-6;
scale = amp *contrast*1e2;
            guess_values=[bg, r, contrast,scale];
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
FF_Sphere_Poly
</FnName>

<Params>
y0
radius
poly
contrast
scale
</Params>

<StartValues>
0.05
60
10
6e-6
0.01
</StartValues>

<ParamNames>
Background [cm-1]
Radius [A]
Polydispersitiy FWHM[%]
Contrast [A-2]
Scale
</ParamNames>

<FnCode>
fine = 100;
low = radius-2*poly*radius/fine; high = radius+2*poly*radius/fine; step = (high-low)/fine;
sigma = (poly*radius/100)/2.354;
contrast = contrast *1e8*1e8; %convert [A-2] to [cm-2];
y = y0;
for rad = low:step:high; if low==high; gauss_weight = 1; else gauss_weight = (1/(sigma * sqrt(2*pi))) * exp( -(rad-radius).^2 / (2*sigma.^2)); end; rq = (rad).* x; V = (4/3)*pi*(rad*1e-8).^3; y = y + gauss_weight*step*(scale./V) .* (3*V*contrast .*  (sin(rq) - (rq).*cos(rq)) ./ (rq).^3).^2; end
</FnCode>

<AutoGuessCode>
            [xmin, i_xmin] = min(x);
            [xmax, i_xmax] = max(x);
            [bg i_ymin] = min(y);
            amp = y(i_xmin) - bg;
            derivative = diff(y,1);
            [temp, i_ymin] = max(derivative);
            r = 4.49/x(i_ymin);
scale = 0.05;
contrast = 0.1*scale/amp;
scale = scale *1e-4;
guess_values = [bg, r, 10, contrast, scale];
</AutoGuessCode>

<PointClickCode>
        text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Text Message
        [xtemp bg]=ginput(1); %Mouse input
        delete(text_handle);drawnow;
        text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
            [xmin ymax]=ginput(1); %Mouse input
            delete(text_handle);drawnow;
            text_handle = grasp_message(['Click on First FF minimum'],1,'sub');  %Grasp Text Message
            [x1 y1]=ginput(1); %Mouse input
            amp = ymax-bg;
            r = 4.49/x1;
contrast = 6e-6;
scale = amp *contrast*1e2;
            guess_values=[bg, r, 0.1, contrast,scale];
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
FF_Poly_Core_Shell_Sphere
</FnName>

<Params>
y0
radius
core_poly
shell
rho_core
rho_shell
rho_matrix
scale
</Params>

<StartValues>
0
50
10
15
6.7e-6
7.88e-8
5.22e-6
1
</StartValues>

<ParamNames>
Background [cm-1]
Core Radius [A]
Core Poly [%]
Shell Thickness [A]
Rho Core [A^-2]
Rho Shell [A^-2]
Rho Matrix [A^-2]
Scale
</ParamNames>

<FnCode>
fine = 25;
low = radius-3*core_poly*radius/100; high = radius+3*core_poly*radius/100; step = (high-low)/fine;
sigma = (core_poly*radius/100)/2.354;
y = y0;
for rad = low:step:high;   if low==high; gauss_weight = 1; else gauss_weight = (1/(sigma * sqrt(2*pi))) * exp( -(rad-radius).^2 / (2*sigma.^2)); end; F1 = 3*(sin(x.*rad)-(x.*rad).*cos(x.*rad))./(x.*rad).^3; F2 = 3*(sin(x.*(rad+shell))-(x.*(rad+shell)).*cos(x.*(rad+shell)))./(x.*(rad+shell)).^3; F1 = F1*(4/3)*pi*rad^3; F2 = F2*(4/3)*pi*(rad+shell)^3; y = y + gauss_weight*step*scale./((4/3)*pi*(rad+shell)^3*10^(-8))*(((rho_core-rho_shell).*F1 + (rho_shell-rho_matrix).*F2).^2); end
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************




%********************************************************************************************************
<Function>

<FnName>
FF_Poly_log_Core_Shell_Sphere
</FnName>

<Params>
y0
radius
core_poly
shell
rho_core
rho_shell
rho_matrix
scale
</Params>

<StartValues>
0
50
10
15
6.7e-6
7.88e-8
5.22e-6
1
</StartValues>

<ParamNames>
Background [cm-1]
Core Radius [A]
Core Poly [%]
Shell Thickness [A]
Rho Core [A^-2]
Rho Shell [A^-2]
Rho Matrix [A^-2]
Scale
</ParamNames>

<FnCode>
fine = 25;
std = sqrt(exp(2*log(radius)+core_poly*core_poly*0.0001)*(exp(core_poly*core_poly*0.0001)-1));
low = radius-3*std; high = radius+3*std; step = (high-low)/fine;
y = y0;
for rad = low:step:high;   if low==high; log_weight = 1; else log_weight = (1/(core_poly*0.01* rad * sqrt(2*pi))) * exp( -(log(rad/radius)).^2 / (2*(core_poly*0.01).^2)); end; F1 = 3*(sin(x.*rad)-(x.*rad).*cos(x.*rad))./(x.*rad).^3; F2 = 3*(sin(x.*(rad+shell))-(x.*(rad+shell)).*cos(x.*(rad+shell)))./(x.*(rad+shell)).^3; F1 = F1*(4/3)*pi*rad^3; F2 = F2*(4/3)*pi*(rad+shell)^3; y = y + log_weight*step*scale./((4/3)*pi*(rad+shell)^3*10^(-8))*(((rho_core-rho_shell).*F1 + (rho_shell-rho_matrix).*F2).^2); end
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************






%********************************************************************************************************
<Function>

<FnName>
FF_Ellipsoidal
</FnName>

<Params>
y0
K
R
e
</Params>

<StartValues>
0
1000
100
5
</StartValues>

<ParamNames>
Background
Scale
Radius
Epsilon
</ParamNames>

<FnCode>
I = 0;
alpha_res = 50;
alpha_step = (pi/2)/alpha_res;
%Angle numeric integration
%For loops must be on one line
for alpha = alpha_step:alpha_step:(pi/2); r = R * sqrt( (sin(alpha).^2) + e*(cos(alpha)^2) );sphere_out = 3*(sin(x.*r)-(x.*r).*cos(x.*r))./(x.*r).^3; I = I + ( (sphere_out.^2) *sin(alpha) *alpha_step);end
y = y0 + K*I;
</FnCode>

<AutoGuessCode>
[xmin, i_xmin] = min(x);
[xmax, i_xmax] = max(x);
[y0 i_ymin] = min(y);
K = y(i_xmin) - y0;
derivative = diff(y,1);
[temp, i_ymin] = max(derivative);
R = 3.83/x(i_ymin);
L = 5*R;  %Just dumm-guess a cylinder length
guess_values = [y0, K, R, L];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Text Message
[xtemp y0]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
[xmin ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on First FF minimum'],1,'sub');  %Grasp Text Message
[x1 y1]=ginput(1); %Mouse input
delete(text_handle); drawnow;
K = ymax-y0;
R = 4.49/x1;
L = 5*R;  %Just dumm-guess a cylinder length
guess_values = [y0, K, R, L];
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
FF_Cylinder
</FnName>

<Params>
y0
K
R
L
</Params>

<StartValues>
0
1000
100
5
</StartValues>

<ParamNames>
Background
Scale
Radius
Length
</ParamNames>

<FnCode>
H = L/2; %length/2
I = 0;
alpha_res = 50;
alpha_step = (pi/2)/alpha_res;
%Angle numeric integration
%For loops must be on one line
for alpha = alpha_step:alpha_step:(pi/2); a = x*H*cos(alpha); J0 = (sin(a)./a).^2; b = x*R*sin(alpha); J1 = (besselj(1,b)./b).^2; I = I + (4*sin(alpha)*J0.*J1*alpha_step); end;
y = y0 + K*I;
</FnCode>


<AutoGuessCode>
[xmin, i_xmin] = min(x);
[xmax, i_xmax] = max(x);
[y0 i_ymin] = min(y);
K = y(i_xmin) - y0;
derivative = diff(y,1);
[temp, i_ymin] = max(derivative);
R = 3.83/x(i_ymin);
L = 5*R;  %Just dumm-guess a cylinder length
guess_values = [y0, K, R, L];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub');  %Grasp Text Message
[xtemp y0]=ginput(1); %Mouse input
delete(text_handle); drawnow;
text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
[xmin ymax]=ginput(1); %Mouse input
delete(text_handle); drawnow;
text_handle = grasp_message(['Click on First FF minimum'],1,'sub');  %Grasp Text Message
[x1 y1]=ginput(1); %Mouse input
delete(text_handle); drawnow;
K = ymax-y0;
R = 4.49/x1;
L = 5*R;  %Just dumm-guess a cylinder length
guess_values = [y0, K, R, L];
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
FF_Gaussian Coil
</FnName>

<Params>
y0
k
rg
</Params>

<StartValues>
0
1000
100
</StartValues>

<ParamNames>
Background
Scale
Radius Gyration
</ParamNames>

<FnCode>
a = (x.^2).*(rg.^2);
b = 2./(a.^2);
y = y0 + k.*b.*(exp(-a)+a-1);
</FnCode>

<AutoGuessCode>
[xmin, i_xmin] = min(x);
[xmax, i_xmax] = max(x);
y0 = y(i_xmax);
k = y(i_xmin) - y0;
rg = sqrt(-3*log(k)/(xmin^2 - xmax^2));
guess_values = [y0, k, rg];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Low Q, High Intensity Point'],1,'sub');  %Grasp Text Message
[xmin ymax]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on High Q, Low Intensity Point'],1,'sub');  %Grasp Text Message
[xmax ymin]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Rg'],1,'sub');  %Grasp Text Message
[qrg  temp]=ginput(1); %Mouse input
delete(text_handle);drawnow;
y0 = ymin;
k = ymax - ymin;
rg = (3/5)*((2*pi/qrg).^2);
guess_values = [y0, k, rg];
</PointClickCode>

</Function>
%********************************************************************************************************




%********************************************************************************************************
<Divider>
----Instrument Functions----
</Divider>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
Linear Step
</FnName>

<Params>
y1
y0
xc
width
</Params>

<StartValues>
1
0
0.5
0.1
</StartValues>

<ParamNames>
High Y Value
Low Y Value
Centre
Step Width
</ParamNames>

<FnCode>
y=zeros(size(x)); li=find(x<(xc-width/2)); ri=find(x>(xc+width/2));mi=find(x>=(xc-width/2) & x<=(xc+width/2));y(li)=y(li)+y0;y(ri)=y(ri)+y1;g=(y1-y0)/width;y(mi)=y(mi)+y0+(x(mi)-(xc-width/2))*g;
</FnCode>

<AutoGuessCode>
[ymax i_ymax] = max(y); %ymax
[ymin i_ymin] = min(y); %ymin
if i_ymax > i_ymin; low = ymin; high = ymax; centre = (x(i_ymax) - x(i_ymin))/2 + x(i_ymin); width = (x(i_ymax) - x(i_ymin))/4; else low = ymax; high = ymin; centre = (x(i_ymin) - x(i_ymax))/2 + x(i_ymax);width = (x(i_ymin) - x(i_ymax))/4; end
if low == 0; low = 1; end
guess_values = [high low centre width];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Bottom of Y Step'],1,'sub');
[xymin ymin]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Top of Y Step'],1,'sub');
[xymax ymax]=ginput(1);
delete(text_handle);drawnow;
if xymax > xymin; low = ymin; high = ymax; centre = (xymax - xymin)/2 + xymin; width = xymax - xymin; else low = ymax; high = ymin; centre = (xymin - xymax)/2 + xymax; width = xymin - xymax; end
if low == 0; low = 1; end
guess_values = [high low centre width];
</PointClickCode>

</Function>
%********************************************************************************************************





%********************************************************************************************************
<Function>

<FnName>
Triangle CONV Linear Step
</FnName>

<Params>
y1
y0
xc
width
base_width
</Params>

<StartValues>
1
0
0.5
0.1
0.1
</StartValues>

<ParamNames>
High Y Value
Low Y Value
Centre
Step Width
Triangle Base Width
</ParamNames>

<FnCode>
x = reshape(x,1,length(x));
%Step fn
y_step=zeros(size(x));
li=find(x<(xc-width/2));
ri=find(x>(xc+width/2));
mi=find(x>=(xc-width/2) & x<=(xc+width/2));
y_step(li)=y_step(li);y_step(ri)=y_step(ri)+y1;
g=y1/width;
y_step(mi)=y_step(mi)+(x(mi)-(xc-width/2))*g;
y_step = y_step + y0;
%%Triangle smear fn (thorough version)
%x_tri = -base_width/2:base_width/7:base_width/2;
%y_tri = zeros(size(x_tri));
%wli = find(x_tri<=0);
%wri = find(x_tri>0);
%g = y1/(base_width/2);
%y_tri(wli) = y_tri(wli) + y1 + (x_tri(wli))*g;
%y_tri(wri) = y_tri(wri) + y1 + (-x_tri(wri))*g;
%y_tri = y_tri./sum(y_tri);
%%Convolute (thorough version)
%for n = 1:length(x); y_conv(n) = 0;  for m = 1:length(x_tri); x_temp = x(n) + x_tri(m); y_temp =interp1(x,y_step,x_temp,'linear','extrap'); y_conv(n) = y_conv(n)+y_temp*y_tri(m); end; end
%y=y_conv;
%Convolute with a triangle  (fast version)
g = 1/(base_width/2);
for n = 1:length(x); y_conv(n) = 0; temp = find(x>=(x(n)-base_width/2) & x<=(x(n)+base_width/2)); x_tri = x(temp); y_tri = zeros(size(x_tri)); wli = find(x_tri<=x(n)); wri = find(x_tri>x(n)); y_tri(wli) = y_tri(wli) + 1 + (x_tri(wli)-x(n))*g; y_tri(wri) = y_tri(wri) + 1 + (x(n)-x_tri(wri))*g; y_tri = y_tri./sum(y_tri); y_conv(n)= sum(y_tri.*y_step(temp)); end
y = y_conv;
</FnCode>

<AutoGuessCode>
[ymax i_ymax] = max(y); %ymax
[ymin i_ymin] = min(y); %ymin
if i_ymax > i_ymin; low = ymin; high = ymax; centre = (x(i_ymax) - x(i_ymin))/2 + x(i_ymin); width = (x(i_ymax) - x(i_ymin))/4; else low = ymax; high = -ymax; centre = (x(i_ymin) - x(i_ymax))/2 + x(i_ymax);width = (x(i_ymin) - x(i_ymax))/4; end
if low == 0; low = 1; end
guess_values = [high low centre width width];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Bottom of Y Step'],1,'sub');
[xymin ymin]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Top of Y Step'],1,'sub');
[xymax ymax]=ginput(1);
delete(text_handle);drawnow;
if xymax > xymin; low = ymin; high = ymax; centre = (xymax - xymin)/2 + xymin; width = xymax - xymin; else low = ymax; high = ymin; centre = (xymin - xymax)/2 + xymax; width = xymin - xymax; end
if low == 0; low = 1; end
guess_values = [high low centre width width];
</PointClickCode>

</Function>
%********************************************************************************************************




%********************************************************************************************************
<Function>

<FnName>
Trapezoidal
</FnName>

<Params>
y0
xc
y1
top_width
wing_width
</Params>

<StartValues>
0
0
0
0
0
</StartValues>

<ParamNames>
Background
Centre
Height
Top Width
Wing Width
</ParamNames>

<FnCode>
y = y0*ones(size(x)); mi = find(x>(xc-top_width) & x <(xc+top_width)); wli = find(x>(xc-top_width-wing_width) & x<=(xc-top_width)); wri = find(x<(xc+top_width+wing_width) & x>=(xc+top_width)); y(mi) = y(mi) + y1; g = y1/wing_width; y(wli) = y(wli) + (x(wli)-(xc-top_width-wing_width))*g; y(wri) = y(wri) + ((xc+top_width+wing_width)-x(wri))*g;
</FnCode>

<AutoGuessCode>
[ymax i_ymax] = max(y); %ymax
[ymin i_ymin] = min(y); %ymin
bck = ymin;
height = ymax-ymin;
centre = x(i_ymax);
base_width = abs(x(i_ymax)-x(i_ymin));
guess_values = [bck centre height base_width base_width];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub'); %Grasp Message
[x y0]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Top Centre'],1,'sub');  %Grasp Message
[xc y1]=ginput(1); %Mouse input, Centre and Peak intensity
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Top Width'],1,'sub');  %Grasp Message
[top_width y]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Base Width'],1,'sub');  %Grasp Message
[base_width y]=ginput(1); %Mouse input
delete(text_handle);drawnow;
top_width = abs(top_width-xc);
base_width=abs(base_width-xc);
y1=y1-y0;
%Put estimated parameters into the output array.
guess_values = [y0, xc, y1, top_width base_width];
</PointClickCode>

</Function>
%********************************************************************************************************

%********************************************************************************************************
<Function>

<FnName>
Triangle
</FnName>

<Params>
y0
xc
y1
base_width
</Params>

<StartValues>
0
0
0
0
</StartValues>

<ParamNames>
Background
Centre
Height
Base Width
</ParamNames>

<FnCode>
y = y0*ones(size(x));
wli = find(x>(xc-(base_width/2)) & x<=xc);
wri = find(x<(xc+(base_width/2)) & x>xc);
g = y1/(base_width/2);
y(wli) = y(wli) + y1 + (x(wli)-xc)*g;
y(wri) = y(wri) + y1 + (xc-x(wri))*g;
</FnCode>

<AutoGuessCode>
[ymax i_ymax] = max(y); %ymax
[ymin i_ymin] = min(y); %ymin
bck = ymin;
height = ymax-ymin;
centre = x(i_ymax);
base_width = abs(x(i_ymax)-x(i_ymin))*2;
guess_values = [bck centre height base_width];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub'); %Grasp Message
[x y0]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak'],1,'sub');  %Grasp Message
[xc y1]=ginput(1); %Mouse input, Centre and Peak intensity
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Base Width'],1,'sub');  %Grasp Message
[base_width y]=ginput(1); %Mouse input
delete(text_handle);drawnow;
base_width=abs(base_width-xc)*2;
y1=y1-y0;
%Put estimated parameters into the output array.
guess_values = [y0, xc, y1, base_width];
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
Log-Normal
</FnName>

<Params>
y0
i0
xc
fwhm
</Params>

<StartValues>
0
1000
0.5
1
</StartValues>

<ParamNames>
Background
Integrated Intensity
Centre
FWHM
</ParamNames>

<FnCode>
sigma = fwhm / (2*xc);
y = y0 + (i0./(x.*sigma*sqrt(2*pi))) .* exp(-(1/(2*sigma^2)).*(log(xc./x)).^2);
</FnCode>

<AutoGuessCode>
[amp i_amp] = max(y);    %Peak Intensity
xc = x(i_amp);         %Centre Position
y0 = min(y);         %Background
x_diff = diff(x); %Differences between adjacent x's.
ytemp = y(1:length(y)-1);
i0 = abs((sum((ytemp-y0).*x_diff)));
sigma = i0/(amp*sqrt(2*pi));
fwhm = 2*sqrt(2*log(2))*sigma; %The sqrt is because this is a 2D gaussian
guess_values = [y0, i0, xc, fwhm];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Background'],1,'sub'); %Grasp Message
[x y0]=ginput(1); %Mouse input
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak'],1,'sub');  %Grasp Message
[xc amp]=ginput(1); %Mouse input, Centre and Peak intensity
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Peak Width'],1,'sub');  %Grasp Message
[fwhm y]=ginput(1); %Mouse input
delete(text_handle);drawnow;
fwhm=abs(fwhm-xc);
amp=amp-y0;
i0 = amp*fwhm*sqrt(pi)/(sqrt(2)*sqrt(2*log(2))); %Convert Peak Intensity to IntInt
%Put estimated parameters into the output array.
guess_values = [y0, i0, xc, fwhm];
</PointClickCode>

</Function>
%********************************************************************************************************




%********************************************************************************************************
<Divider>
----Magnetic Scattering----
</Divider>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
Cosine^2
</FnName>

<Params>
y0
amp
phase
</Params>

<StartValues>
0
0
0
</StartValues>

<ParamNames>
Background
Amplitude
Phase
</ParamNames>

<FnCode>
y = y0+ abs(amp).*(cos((x+phase)*2*pi/360)).^2;;
</FnCode>

<AutoGuessCode>
[Amax i_amp_max] = max(y); %Amplitude
[Amin i_amp_min] = min(y); %Amplitude
y0 = Amin;
amp = Amax-Amin;
phase = x(i_amp_max);
guess_values = [y0, amp, phase];
</AutoGuessCode>

<PointClickCode>
text_handle = grasp_message(['Click on Cosine Min'],1,'sub');
[x_amp_min Amin]=ginput(1);
delete(text_handle);drawnow;
text_handle = grasp_message(['Click on Cosine Max'],1,'sub');
[x_amp_max Amax]=ginput(1);
delete(text_handle);drawnow;
y0 = Amin;
amp = Amax - Amin;
phase = x_amp_max;
guess_values = [y0, amp, phase];
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Divider>
----Polarisation & Analysis----
</Divider>
%********************************************************************************************************




%********************************************************************************************************
<Function>

<FnName>
3He Flipping Ratio vs. Time
</FnName>

<Params>
p
opacity
p0
t0
t1
</Params>

<StartValues>
0.99
30
0.75
0
300
</StartValues>

<ParamNames>
Polariser
Opacity
Initial 3He Polarisation
Time Offset, T0
Decay constant, T1
</ParamNames>

<FnCode>
%Constants
sigma_a = 5333; %Barns   absorbtion cross-section for unpolarised neutrons
sigma_a = sigma_a * 1e-28; %m^2
wav0 = 1.7982; %angs
Na = 6.02214179*10^23; %Avagadro
R = 8.314;  %Molar gas constant
T = 300;  %(K) Cell Temperature
PHe = p0*exp(-(x+t0)/t1);
T_para = exp(-opacity*100000*(Na/(R*T*100))*(sigma_a/wav0)*(1-PHe));
T_anti = exp(-opacity*100000*(Na/(R*T*100))*(sigma_a/wav0)*(1+PHe));
y = (p*T_para + (1-p)*T_anti) ./ (p*T_anti + (1-p)*T_para);
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
Combined Supermirror--Analyser Polarisation
</FnName>

<Params>
p
opacity
phe0
t0
t1
</Params>

<StartValues>
0.9
30
0.75
0
300
</StartValues>

<ParamNames>
Polariser
Opacity
Initial 3He Polarisation
Time Offset
Decay constant
</ParamNames>

<FnCode>
%Constants
sigma_a = 5333; %Barns   absorbtion cross-section for unpolarised neutrons
sigma_a = sigma_a * 1e-28; %m^2
wav0 = 1.7982; %angs
Na = 6.02214179*10^23; %Avagadro
R = 8.314;  %Molar gas constant
T = 300;  %(K) Cell Temperature
cons = 100000*(Na/(R*T*100))*(sigma_a/wav0);
PHe = phe0*exp(-(x+t0)/t1);
T_para = 0.5*exp(-opacity*cons*(1-PHe));
T_anti = 0.5*exp(-opacity*cons*(1+PHe));
a = (T_para-T_anti)./(T_para+T_anti);
y = p.*a;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Divider>
----Testing----
</Divider>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
Gabel Protien Model
</FnName>

<Params>
I0
y0
</Params>

<StartValues>
1
0
</StartValues>

<ParamNames>
Intensity Scale
Background
</ParamNames>

<FnCode>
y = ff_gabel_protien(x);
y = y*I0 + y0;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************



%********************************************************************************************************
<Function>

<FnName>
Bragg Ring
</FnName>

<Params>
I0
R
q0
delta_q_fwhm
orders
</Params>

<StartValues>
1
0.1
5e-4
1e-4
10
</StartValues>

<ParamNames>
Multiplier
Reflectivity
q_1st_order
delta_q
Orders
</ParamNames>

<FnCode>
y = zeros(size(x));
sigma = delta_q_fwhm/2.354;
for n = 1:orders; q = q0*n; s = sigma*n; int = (R^n)./x; i = (int/(s*sqrt(2*pi))) .*exp( -((x - q).^2)./(2*s.^2)); y = y+i; end
y =I0.*y;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************


%********************************************************************************************************
<Function>

<FnName>
Bragg Ring + Background
</FnName>

<Params>
I0
R
q0
delta_q_fwhm
orders
bck
</Params>

<StartValues>
1
0.1
5e-4
1e-4
10
0.1
</StartValues>

<ParamNames>
Multiplier
Reflectivity
q_1st_order
delta_q
Orders
Background
</ParamNames>

<FnCode>
y = zeros(size(x));
sigma = delta_q_fwhm/2.354;
for n = 1:orders; q = q0*n; s = sigma*n; int = (R^n)./x; i = (int/(s*sqrt(2*pi))) .*exp( -((x - q).^2)./(2*s.^2)); y = y+i; end
y =I0.*y+bck;
</FnCode>

<AutoGuessCode>
</AutoGuessCode>

<PointClickCode>
</PointClickCode>

</Function>
%********************************************************************************************************

